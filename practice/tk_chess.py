"""
Tkinter Chess vs Computer
Three difficulty levels: easy (random), medium (minimax depth 2), hard (minimax depth 3 alpha-beta)
Requires: python-chess
Install: pip install python-chess

Run: python tk_chess.py

Author: Generated by ChatGPT
"""

import tkinter as tk
from tkinter import messagebox, simpledialog
import threading
import random
import time

try:
    import chess
except Exception as e:
    raise SystemExit("This script requires the `python-chess` package. Install it with: pip install python-chess")

# Unicode chess pieces
UNICODE_PIECES = {
    'P': '\u2659', 'N': '\u2658', 'B': '\u2657', 'R': '\u2656', 'Q': '\u2655', 'K': '\u2654',
    'p': '\u265F', 'n': '\u265E', 'b': '\u265D', 'r': '\u265C', 'q': '\u265B', 'k': '\u265A'
}

# Simple material values
PIECE_VALUES = {
    chess.PAWN: 100,
    chess.KNIGHT: 320,
    chess.BISHOP: 330,
    chess.ROOK: 500,
    chess.QUEEN: 900,
    chess.KING: 20000
}

# Basic evaluation: material + mobility (legal moves count) * small factor
def evaluate_board(board: chess.Board) -> int:
    if board.is_checkmate():
        # if current side to move is checkmated, huge negative value
        return -999999 if board.turn else 999999

    material = 0
    for square in chess.SQUARES:
        piece = board.piece_at(square)
        if piece:
            value = PIECE_VALUES.get(piece.piece_type, 0)
            material += value if piece.color == chess.WHITE else -value

    # mobility
    # count legal moves for side to move and opponent
    moves_side = len(list(board.legal_moves))
    # flip turn temporarily to count opponent moves
    board.push(chess.Move.null())
    opp_moves = len(list(board.legal_moves))
    board.pop()

    mobility = (moves_side - opp_moves) * 10

    # combine
    score = material + (mobility if board.turn == chess.WHITE else -mobility)
    return score

# Minimax with alpha-beta
def minimax(board: chess.Board, depth: int, alpha: int, beta: int, maximizing: bool):
    if depth == 0 or board.is_game_over():
        return evaluate_board(board), None

    best_move = None
    if maximizing:
        max_eval = -10**9
        for move in board.legal_moves:
            board.push(move)
            eval_score, _ = minimax(board, depth-1, alpha, beta, False)
            board.pop()
            if eval_score > max_eval:
                max_eval = eval_score
                best_move = move
            alpha = max(alpha, eval_score)
            if beta <= alpha:
                break
        return max_eval, best_move
    else:
        min_eval = 10**9
        for move in board.legal_moves:
            board.push(move)
            eval_score, _ = minimax(board, depth-1, alpha, beta, True)
            board.pop()
            if eval_score < min_eval:
                min_eval = eval_score
                best_move = move
            beta = min(beta, eval_score)
            if beta <= alpha:
                break
        return min_eval, best_move

# AI move chooser
def choose_ai_move(board: chess.Board, level: str) -> chess.Move:
    moves = list(board.legal_moves)
    if not moves:
        return None

    if level == 'easy':
        return random.choice(moves)
    elif level == 'medium':
        # minimax depth 2 (i.e., 2 plies)
        _, move = minimax(board, 2, -10**9, 10**9, board.turn == chess.WHITE)
        return move if move else random.choice(moves)
    else:  # hard
        _, move = minimax(board, 3, -10**9, 10**9, board.turn == chess.WHITE)
        return move if move else random.choice(moves)

# GUI Application
class ChessApp:
    def __init__(self, master):
        self.master = master
        master.title("Chess vs Computer")
        self.board = chess.Board()

        # user plays as White by default
        self.user_color = chess.WHITE
        self.ai_level = 'medium'

        top_frame = tk.Frame(master)
        top_frame.pack(side=tk.TOP, pady=6)

        self.level_var = tk.StringVar(value='medium')
        tk.Label(top_frame, text="AI Level:").pack(side=tk.LEFT)
        tk.OptionMenu(top_frame, self.level_var, 'easy', 'medium', 'hard', command=self.set_level).pack(side=tk.LEFT)

        tk.Button(top_frame, text="New Game (You:White)", command=self.new_game_white).pack(side=tk.LEFT, padx=6)
        tk.Button(top_frame, text="New Game (You:Black)", command=self.new_game_black).pack(side=tk.LEFT, padx=6)
        tk.Button(top_frame, text="Resign", command=self.resign).pack(side=tk.LEFT, padx=6)

        self.status = tk.Label(master, text="Welcome to Chess!", font=(None, 12))
        self.status.pack(side=tk.TOP)

        self.board_frame = tk.Frame(master)
        self.board_frame.pack()

        self.square_buttons = {}
        self.selected_square = None

        for r in range(8):
            for c in range(8):
                btn = tk.Button(self.board_frame, text='', font=(None, 32), width=2, height=1,
                                command=lambda sq=(7-r)*8 + c: self.on_square_click(sq))
                btn.grid(row=r, column=c)
                self.square_buttons[(7-r)*8 + c] = btn

        self.update_board_ui()

        # If user is black, AI should play first as white
        if self.user_color == chess.BLACK:
            self.master.after(200, self.make_ai_move_async)

    def set_level(self, v):
        self.ai_level = v
        self.status.config(text=f"AI level set to {v}")

    def new_game_white(self):
        self.board.reset()
        self.user_color = chess.WHITE
        self.status.config(text="New game: You are White. Your move.")
        self.update_board_ui()

    def new_game_black(self):
        self.board.reset()
        self.user_color = chess.BLACK
        self.status.config(text="New game: You are Black. AI (White) thinking...")
        self.update_board_ui()
        self.master.after(100, self.make_ai_move_async)

    def resign(self):
        result = "You resigned."
        if self.board.turn == self.user_color:
            result += " AI wins."
        else:
            result += " You win."
        messagebox.showinfo("Resign", result)
        self.board.reset()
        self.update_board_ui()

    def on_square_click(self, square_index):
        if self.board.is_game_over():
            messagebox.showinfo("Game Over", "Game is over. Start a new game.")
            return

        # Only accept user moves when it's user's turn
        if self.board.turn != self.user_color:
            return

        piece = self.board.piece_at(square_index)
        if self.selected_square is None:
            # select if there's a piece of user's color
            if piece and piece.color == self.user_color:
                self.selected_square = square_index
                self.highlight_square(square_index, True)
        else:
            # try to make move from selected_square to square_index
            move = chess.Move(self.selected_square, square_index)
            # handle promotions (auto promote to queen if reaching last rank)
            if move in self.board.legal_moves:
                self.board.push(move)
                self.selected_square = None
                self.clear_highlights()
                self.update_board_ui()
                self.check_game_over()
                # AI move
                if not self.board.is_game_over():
                    self.master.after(100, self.make_ai_move_async)
            else:
                # try promotion to queen if applicable
                if chess.Move(self.selected_square, square_index, promotion=chess.QUEEN) in self.board.legal_moves:
                    self.board.push(chess.Move(self.selected_square, square_index, promotion=chess.QUEEN))
                    self.selected_square = None
                    self.clear_highlights()
                    self.update_board_ui()
                    self.check_game_over()
                    if not self.board.is_game_over():
                        self.master.after(100, self.make_ai_move_async)
                else:
                    # reset selection if clicked elsewhere
                    self.highlight_square(self.selected_square, False)
                    self.selected_square = None

    def highlight_square(self, square, on=True):
        btn = self.square_buttons[square]
        if on:
            btn.config(bg='yellow')
        else:
            btn.config(bg='SystemButtonFace')

    def clear_highlights(self):
        for btn in self.square_buttons.values():
            btn.config(bg='SystemButtonFace')

    def update_board_ui(self):
        for sq, btn in self.square_buttons.items():
            piece = self.board.piece_at(sq)
            if piece:
                btn.config(text=UNICODE_PIECES.get(piece.symbol(), piece.symbol()))
            else:
                btn.config(text='')

        # color squares to look like a chessboard
        for r in range(8):
            for c in range(8):
                sq = (7-r)*8 + c
                btn = self.square_buttons[sq]
                light = (r + c) % 2 == 0
                btn.config(bg='#F0D9B5' if light else '#B58863')

    def check_game_over(self):
        if self.board.is_checkmate():
            winner = 'White' if not self.board.turn else 'Black'
            messagebox.showinfo("Checkmate", f"Checkmate! {winner} wins.")
        elif self.board.is_stalemate():
            messagebox.showinfo("Stalemate", "Draw by stalemate.")
        elif self.board.is_insufficient_material():
            messagebox.showinfo("Draw", "Draw by insufficient material.")
        elif self.board.can_claim_threefold_repetition():
            messagebox.showinfo("Draw", "Draw by repetition (claimable).")

    def make_ai_move_async(self):
        # Run AI in background thread to keep UI responsive
        t = threading.Thread(target=self.make_ai_move)
        t.daemon = True
        t.start()

    def make_ai_move(self):
        # small delay for realism
        time.sleep(0.3)
        level = self.level_var.get()
        self.ai_level = level
        # choose move
        move = choose_ai_move(self.board, self.ai_level)
        if move is None:
            self.update_board_ui()
            self.check_game_over()
            return
        self.board.push(move)
        # update UI back in main thread
        self.master.after(50, self.update_board_ui)
        self.master.after(60, self.check_game_over)


if __name__ == '__main__':
    root = tk.Tk()
    app = ChessApp(root)
    root.mainloop()
